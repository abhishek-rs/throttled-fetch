{"version":3,"file":"throttled-fetch.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["const fetch = require('cross-fetch');\n\n/*\nClient side throttling\nRead more at - https://sre.google/sre-book/handling-overload/\n*/\n\n/* Utils */\n\n// Remove query params to reduce the no. of unique keys in the requestsMap\nconst sanitizeUrl = (url: string) => {\n  const urlMinusQuery = url.split('?')[0];\n  return urlMinusQuery;\n};\n\nexport const diffInSeconds = (a: Date, b: Date) => {\n  return Math.round((a.valueOf() - b.valueOf()) / 1000);\n};\n\n/* --- */\n\n/* Requests' recent history store */\n\n// We need to keep the no. of requests and no. of accepted requests for the last [windowLength] seconds and disregard the rest\n// This is done here by using arrays of [windowLength] items, for every url, each representing the second that is [index] seconds away from head\n// i.e index 0 represents the head, index 1 represents 1 second ahead of the head\ninterface WindowItem {\n  requests: number;\n  accepts: number;\n  time: Date;\n}\ninterface RequestMapEntry {\n  head: Date;\n  values: Array<WindowItem>;\n}\ninterface ThrottlerOptions {\n  K: number;\n  windowLength: number; // seconds\n  cleanupFrequency: number; // seconds\n}\n\n// A place to store the requests' totalCount and acceptance count using their urls as keys\nexport const requestsMap: Map<string, RequestMapEntry> = new Map();\n\n/* --- */\n\n/* Core methods */\n\n// We need the 'time' value here for every item because a lot of these items could be outdated (out of our current window of interest),\n// as we only clean them up on a need-to-do basis when we replace an item\n// During the update phase, if we arrive at a time that is more than [windowLength] seconds from head we update the head\n// For more on update see updateRequestValues below\nconst getTwoMinuteWindow = (now: Date, windowLength: number) => ({\n  head: now,\n  values: new Array(windowLength).fill({\n    requests: 0,\n    accepts: 0,\n    time: null,\n  }),\n});\n\nlet cleanUpTaskId: NodeJS.Timer;\n\n// Returns the sum of all [requests, acceptedRequests] in the last [windowLength] second window\nexport const getRequestValues = (\n  reqWindow: RequestMapEntry,\n  now: Date,\n  windowLength: number\n) => {\n  const { values: reqValues } = reqWindow;\n  return reqValues.reduce(\n    (acc: Array<number>, { time, requests, accepts }: WindowItem) => {\n      if (time && diffInSeconds(now, time) < windowLength) {\n        return [acc[0] + requests, acc[1] + accepts];\n      }\n      return acc;\n    },\n    [0, 0]\n  );\n};\n\n// If the time we are updating for, represented by 'now', is out of the range of current head,\n// we replace the head with 'now' and set its values to the first item\n// If the time we are updating falls within the window of [head + winddowLength seconds] we update the item representing the current second\nexport const updateRequestValues = (\n  url: string,\n  now: Date,\n  windowLength: number,\n  incRequests: boolean = false,\n  incAccepts: boolean = false\n) => {\n  const requestWindow = requestsMap.get(url);\n\n  if (requestWindow) {\n    const { head, values: reqValues } = requestWindow;\n    const diffFromHead = diffInSeconds(now, head);\n\n    if (diffFromHead >= windowLength) {\n      reqValues[0] = {\n        requests: incRequests ? 1 : 0,\n        accepts: incAccepts ? 1 : 0,\n        time: now,\n      };\n      requestsMap.set(url, { head: now, values: reqValues });\n    } else {\n      const currentVal = reqValues[diffFromHead];\n      reqValues[diffFromHead] = {\n        requests: incRequests ? currentVal.requests + 1 : currentVal.requests,\n        accepts: incAccepts ? currentVal.accepts + 1 : currentVal.accepts,\n        time: now,\n      };\n    }\n  }\n\n  return;\n};\n\n// Go through the entries and clean up all the ones that haven't been updated in the last 2.5 * [windowLength] seconds\nconst cleanUpOldEntries = (windowLength: number) => () => {\n  requestsMap.forEach(({ head }, key) => {\n    if (diffInSeconds(new Date(), head) > 2.5 * windowLength) {\n      requestsMap.delete(key);\n    }\n  });\n};\n\n/* --- */\n\n// Multiplier that determines aggressiveness of throttling\n// Higher value is less agressive, 2 is recommended\nconst defaultK = 2;\n\n// Determines how many seconds wide the requestWindow is.\n// Default is 120 seconds i.e rejection probability is based on how well the backend has been performing in the last 2 minutes\nconst defaultWindowLength = 120;\n\n// Determines how often requestsMap is cleaned (delete old keys), default 60 seconds\nconst defaultCleanUpFreq = 60;\n\nconst defaultOptions = {\n  K: defaultK,\n  windowLength: defaultWindowLength,\n  cleanupFrequency: defaultCleanUpFreq,\n};\n\nexport const throttler = ({\n  K = defaultK,\n  windowLength = defaultWindowLength,\n  cleanupFrequency = defaultCleanUpFreq,\n}: ThrottlerOptions = defaultOptions) => (url: string) => {\n  if (!cleanUpTaskId) {\n    // Setup cleanup job to run every minute if it hasn't already been setup\n    cleanUpTaskId = setInterval(\n      cleanUpOldEntries(windowLength),\n      cleanupFrequency * 1000\n    );\n  }\n\n  const now = new Date();\n  if (!requestsMap.has(url)) {\n    // If the requestsMap doesn't have an entry for the current url, create one\n    requestsMap.set(url, getTwoMinuteWindow(now, windowLength));\n  }\n  const requestWindow: RequestMapEntry = requestsMap.get(url)!;\n  const [requests, accepts] = getRequestValues(\n    requestWindow,\n    now,\n    windowLength\n  );\n\n  const chanceOfThrottle = Math.max(\n    0,\n    (requests - K * accepts) / (requests + 1)\n  );\n\n  if (Math.random() < chanceOfThrottle) {\n    return [true, (x: boolean) => x] as const;\n  }\n\n  return [\n    false,\n    (isSuccess: boolean) =>\n      updateRequestValues(url, now, windowLength, true, isSuccess),\n  ] as const;\n};\n\nconst throttledFetch = (throttleOptions: ThrottlerOptions) => (\n  url: string,\n  options: object = {},\n  applyThrottling: boolean = true,\n  removeQueryParams: boolean = true,\n  throttle400s: boolean = false\n) => {\n  let callOnComplete: any;\n  if (applyThrottling) {\n    let shouldThrottle;\n    const requestThrottler = throttler(throttleOptions);\n    [shouldThrottle, callOnComplete] = requestThrottler(\n      removeQueryParams ? sanitizeUrl(url) : url\n    );\n\n    if (shouldThrottle) {\n      return Promise.reject(new Error('The request was throttled.'));\n    }\n  }\n\n  const throttleThresholdCode = throttle400s ? 400 : 500;\n\n  return fetch(url, options)\n    .then((res: Response) => {\n      res?.status < throttleThresholdCode\n        ? callOnComplete(true)\n        : callOnComplete(false);\n      return res;\n    })\n    .catch((err: Error) => {\n      if (err.name === 'AbortError') {\n        throw err;\n      } else {\n        callOnComplete(false);\n        throw err;\n      }\n    });\n};\n\nexport default throttledFetch;\n"],"names":["cleanUpTaskId","fetch","require","diffInSeconds","a","b","Math","round","valueOf","requestsMap","Map","getRequestValues","reqWindow","now","windowLength","values","reduce","acc","time","requests","accepts","updateRequestValues","url","incRequests","incAccepts","requestWindow","get","reqValues","diffFromHead","head","set","currentVal","defaultOptions","K","cleanupFrequency","throttler","setInterval","forEach","key","Date","cleanUpOldEntries","has","Array","fill","getTwoMinuteWindow","chanceOfThrottle","max","random","x","isSuccess","throttleOptions","options","applyThrottling","removeQueryParams","throttle400s","callOnComplete","requestThrottler","split","sanitizeUrl","Promise","reject","Error","throttleThresholdCode","then","res","status","err","name"],"mappings":"oEAAA,IA6DIA,EA7DEC,EAAQC,QAAQ,eAeTC,EAAgB,SAACC,EAASC,UAC9BC,KAAKC,OAAOH,EAAEI,UAAYH,EAAEG,WAAa,MA0BrCC,EAA4C,IAAIC,IAsBhDC,EAAmB,SAC9BC,EACAC,EACAC,UAE8BF,EAAtBG,OACSC,QACf,SAACC,SAAsBC,IAAAA,KAAMC,IAAAA,SAAUC,IAAAA,eACjCF,GAAQf,EAAcU,EAAKK,GAAQJ,EAC9B,CAACG,EAAI,GAAKE,EAAUF,EAAI,GAAKG,GAE/BH,IAET,CAAC,EAAG,KAOKI,EAAsB,SACjCC,EACAT,EACAC,EACAS,EACAC,YADAD,IAAAA,GAAuB,YACvBC,IAAAA,GAAsB,OAEhBC,EAAgBhB,EAAYiB,IAAIJ,MAElCG,EAAe,KACKE,EAAcF,EAAtBV,OACRa,EAAezB,EAAcU,EADCY,EAA5BI,SAGJD,GAAgBd,EAClBa,EAAU,GAAK,CACbR,SAAUI,EAAc,EAAI,EAC5BH,QAASI,EAAa,EAAI,EAC1BN,KAAML,GAERJ,EAAYqB,IAAIR,EAAK,CAAEO,KAAMhB,EAAKE,OAAQY,QACrC,KACCI,EAAaJ,EAAUC,GAC7BD,EAAUC,GAAgB,CACxBT,SAAUI,EAAcQ,EAAWZ,SAAW,EAAIY,EAAWZ,SAC7DC,QAASI,EAAaO,EAAWX,QAAU,EAAIW,EAAWX,QAC1DF,KAAML,MA8BRmB,EAAiB,CACrBC,EAVe,EAWfnB,aAP0B,IAQ1BoB,iBALyB,IAQdC,EAAY,6BAIHH,QAHpBC,EAAAA,aAhBe,QAiBfnB,aAAAA,aAb0B,UAc1BoB,iBAAAA,aAXyB,YAYc,SAACZ,GACnCtB,IAEHA,EAAgBoC,YAlCM,SAACtB,UAAyB,WAClDL,EAAY4B,SAAQ,WAAWC,OAART,IAAAA,KACjB1B,EAAc,IAAIoC,KAAQV,GAAQ,IAAMf,GAC1CL,SAAmB6B,OAgCnBE,CAAkB1B,GACC,IAAnBoB,QAIErB,EAAM,IAAI0B,KACX9B,EAAYgC,IAAInB,IAEnBb,EAAYqB,IAAIR,EA7GO,SAACT,EAAWC,SAA0B,CAC/De,KAAMhB,EACNE,OAAQ,IAAI2B,MAAM5B,GAAc6B,KAAK,CACnCxB,SAAU,EACVC,QAAS,EACTF,KAAM,QAwGe0B,CAAmB/B,EAAKC,QAEzCW,EAAiChB,EAAYiB,IAAIJ,KAC3BX,EAC1Bc,EACAZ,EACAC,GAHKK,OAMD0B,EAAmBvC,KAAKwC,IAC5B,GACC3B,EAAWc,SAAgBd,EAAW,WAGrCb,KAAKyC,SAAWF,EACX,EAAC,EAAM,SAACG,UAAeA,IAGzB,EACL,EACA,SAACC,UACC5B,EAAoBC,EAAKT,EAAKC,GAAc,EAAMmC,uBAIjC,SAACC,UAAsC,SAC5D5B,EACA6B,EACAC,EACAC,EACAC,OAEIC,cALJJ,IAAAA,EAAkB,aAClBC,IAAAA,GAA2B,YAC3BC,IAAAA,GAA6B,YAC7BC,IAAAA,GAAwB,GAGpBF,EAAiB,OAEMjB,EAAUe,EACAM,CACjCH,EA5Lc,SAAC/B,UACGA,EAAImC,MAAM,KAAK,GA2LbC,CAAYpC,GAAOA,MADxBiC,mBAKRI,QAAQC,OAAO,IAAIC,MAAM,mCAI9BC,EAAwBR,EAAe,IAAM,WAE5CrD,EAAMqB,EAAK6B,GACfY,MAAK,SAACC,UAEDT,SADJS,SAAAA,EAAKC,QAASH,GAGPE,YAEF,SAACE,QACW,eAAbA,EAAIC,MAGNZ,GAAe,GAFTW"}